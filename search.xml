<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python - Vectorization and Broadcasting]]></title>
    <url>%2F2018%2F02%2F08%2FPython-Broadcasting%2F</url>
    <content type="text"><![CDATA[VectorizationIn the course Neural Networks and Deep Learning, Andrew Ng introduces vetorization in machine learning by giving the following examples: 123456789101112131415161718192021222324import numpy as npimport timea = np.random.rand(1000000)b = np.random.rand(1000000)# vectorizationtic = time.time()c = np.dot(a,b)toc = time.time()print(c)print("Vectorization:" + str(1000*(toc-tic)) + "ms")c = 0# vectorizationtic = time.time()for i in range(1000000):c += a[i]*b[i]toc = time.time()print(c)print("For loop:" + str(1000*(toc-tic)) + "ms") The above code uses vetorization and for loop to do the same calculation. However, the for loop version cost much more time than the vectorization version. Output:249888.154501Vectorization:2.2249221801757812ms249888.154501For loop:599.0450382232666ms The above example indicates that in python itâ€™s more efficient to use vectorization instead of for loop. This kind of technique is also called SIMD(single instruction multiple data) in CPU/GPU parallel processing. Broadcasting The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is â€œbroadcastâ€ across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. NumPy operations are usually done on pairs of arrays on an element-by-element basis. In the simplest case, the two arrays must have exactly the same shape, as in the following example: 1234&gt;&gt;&gt; a = np.array([1.0, 2.0, 3.0])&gt;&gt;&gt; b = np.array([2.0, 2.0, 2.0])&gt;&gt;&gt; a * barray([ 2., 4., 6.]) NumPyâ€™s broadcasting rule relaxes this constraint when the arraysâ€™ shapes meet certain constraints. The simplest broadcasting example occurs when an array and a scalar value are combined in an operation: 1234&gt;&gt;&gt; a = np.array([1.0, 2.0, 3.0])&gt;&gt;&gt; b = 2.0&gt;&gt;&gt; a * barray([ 2., 4., 6.]) The result is equivalent to the previous example where b was an array. We can think of the scalar b being stretched during the arithmetic operation into an array with the same shape as a. The new elements in b are simply copies of the original scalar. The stretching analogy is only conceptual. NumPy is smart enough to use the original scalar value without actually making copies, so that broadcasting operations are as memory and computationally efficient as possible. The code in the second example is more efficient than that in the first because broadcasting moves less memory around during the multiplication (b is a scalar rather than an array). General Broadcasting RulesWhen operating on two arrays, NumPy compares their shapes element-wise. It starts with the trailing dimensions, and works its way forward. Two dimensions are compatible when they are equal one of them is 1 Arrays donâ€™t have to have the same number of dimensions. For example, if you have a 256x256x3 array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with 3 values. Image (3d array): 256 x 256 x 3Scale (1d array): 3Result (3d array): 256 x 256 x 3 When either of the dimensions compared is one, the other is used. In other words, dimensions with size 1 are stretched or â€œcopiedâ€ to match the other. A (4d array): 8 x 1 x 6 x 1B (3d array): 7 x 1 x 5Result (4d array): 8 x 7 x 6 x 5 A (2d array): 5 x 4B (1d array): 1Result (2d array): 5 x 4 A (2d array): 5 x 4B (1d array): 4Result (2d array): 5 x 4 A (3d array): 15 x 3 x 5B (3d array): 15 x 1 x 5Result (3d array): 15 x 3 x 5 A (3d array): 15 x 3 x 5B (2d array): 3 x 5Result (3d array): 15 x 3 x 5 Here are examples of shapes that do not broadcast: A (1d array): 3B (1d array): 4 # trailing dimensions do not match A (2d array): 2 x 1B (3d array): 8 x 4 x 3 # second from last dimensions mismatched References Neural Networks and Deep Learning Broadcasting â€” NumPy v1.12 Manual]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NumPy</tag>
        <tag>vectorization</tag>
        <tag>broadcasting</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Analytics Introduction]]></title>
    <url>%2F2018%2F02%2F07%2FWeekly-Report-20180207%2F</url>
    <content type="text"><![CDATA[In order to better evaluate how the website works, I use Google Analytics to monitor statistics of the website. Here is a brief introduction of how Google Analytics works and what we can get from it. HomeIn home page there are portals to most important statistics. Real-TimeIn Real-Time page, we can monitor our website in real-time mode, which is useful for website adminstrator. In the picture we can see that there is no active users on site. AudienceIn Audience page, information of users are listed. We can see the number of users, sessions/pageviews of users and demographics of users. AquisitionIn Aquisition page, it shows how users are directed to this website, which is useful for analyzing how to get more users. BehaviorIn Behavior page, different kinds of website behaviors are presented. This section could help website administrator to evaluate the efficiency and accessibility of website. In this section I recommend Behavior Flow cause it shows how users jump between pages. ReportHere attached sample Google Analytics report for this website. Analytics Website Monitor Acquisition OverviewAnalytics Website Monitor Behavior FlowAnalytics Website Monitor LocationAnalytics Website Monitor Overview]]></content>
      <categories>
        <category>Documentation</category>
      </categories>
      <tags>
        <tag>Google Analytics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PCA - Mathematics (1)]]></title>
    <url>%2F2018%2F01%2F30%2FPCA-Mathematical-principle%2F</url>
    <content type="text"><![CDATA[Principal component analysis (PCA) is a statistical procedure that uses an orthogonal transformation to convert a set of observations of possibly correlated variables into a set of values of linearly uncorrelated variables called principal components. Vector representation and Dimensionality reduction of dataIn general, in data mining and machine learning, data are represented as vectors.For example:$$ (500,240,25,13,2312.15)^ð–³ $$ As we know, the scale of dimensionality of data is in proportion to complexity of machine learning algorithm, so we can reduce dimensionality to simplify calculation. Obviuosly, dimensionality reduction means loss of information. However, due to the correlation among data, we could minimize the loss in the above process, which is the purpose of PCA. Change of basesInner productInner product of two vectors is defined as: $$ (a_1,a_2,â‹¯,a_n)^ð–³â‹…(b_1,b_2,â‹¯,b_n)^ð–³=a_1b_1+a_2b_2+â‹¯+a_nb_n $$ and $$ Aâ‹…B=|A||B|cos(a) $$ Let |B| = 1, that is $ Aâ‹…B=|A|cos(a) $. The above definition could be explained that the inner product of A and B equals the vector length projected from A to B. BaseTo describe a vector, we need a set of bases. Then the vector could be represented as the combination of projections to all bases. Usually, we choose (1,0) and (0,1) as bases, but actually we can choose any two linearly independent vectors as bases. For example, we can use $ (\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}) $ and $ (\frac{1}{\sqrt{2}}, -\frac{1}{\sqrt{2}}) $ as new bases to represent the same vector. Matrix representation of form changeFor example, we want to transform (3, 2) based on new bases $ (\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}) $ and $ (\frac{1}{\sqrt{2}}, -\frac{1}{\sqrt{2}}) $, which could be represented by the following form: $$\left(\begin{matrix}\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\-\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}}\end{matrix}\right)\left(\begin{matrix}1 &amp; 2 &amp; 3 \\1 &amp; 2 &amp; 3\end{matrix}\right)=\left(\begin{matrix}\frac{2}{\sqrt{2}} &amp; \frac{4}{\sqrt{2}} &amp; \frac{6}{\sqrt{2}} \\0 &amp; 0 &amp; 0\end{matrix}\right)$$ In general, if we have M N-dimesion vector and want to transform them into R N-dimesion new spaces, we first construct matrix A combining R bases by row, then construct matrix B combining vectors by column. The product of A and B is the result, where the column in AB is transformed from column in A. The above shows an explanation of matrix product:product of two matrices(AB) means to transform each column vector in B to the new space with rows in A as bases.]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Mathematics</tag>
        <tag>PCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6 features (3)]]></title>
    <url>%2F2018%2F01%2F30%2FECMAScript-6-3%2F</url>
    <content type="text"><![CDATA[Data-Structure Set12345var s = new Set();[2,3,5,4,5,2,2].map(x =&gt; s.add(x))for (i of s) &#123;console.log(i)&#125;// 2 3 4 5 Methods: sizeï¼šReturns the number of values in the Set object. add(value)ï¼šAppends a new element with the given value to the Set object. Returns the Set object. delete(value)ï¼šRemoves the element associated to the value and returns the value that has(value)ï¼šReturns a boolean asserting whether an element is present with the given value in the Set object or not. clear()ï¼šRemoves all elements from the Set object. Tips: Set constructor could receive an array to eliminate duplicate. 12const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5 For set, 5 and â€˜5â€™ are different, and objects are always different. 1234567let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 Iteration keys()ï¼šreturn an iterator for keys values()ï¼šreturn an iterator for values entries()ï¼šReturns a new Iterator object that contains an array of [value, value] for each element in the Set object, in insertion order. 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123;console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123;console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123;console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"] forEach()ï¼šCalls callbackFn once for each value present in the Set object, in insertion order.If a thisArg parameter is provided to forEach, it will be used as the this value for each callback. 12345set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + ' : ' + value))// 1 : 1// 4 : 4// 9 : 9 MapProperties/Methodssize12345const map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2 set(key, value)12345const m = new Map();m.set('edition', 6)m.set(262, 'standard')m.set(undefined, 'nah') get(key)123456const m = new Map();const hello = function() &#123;console.log('hello');&#125;;m.set(hello, 'Hello ES6!') // key is a function!m.get(hello) // Hello ES6! has(key)return a boolean shows if a key exists in the map object.12345678910const m = new Map();m.set('edition', 6);m.set(262, 'standard');m.set(undefined, 'nah');m.has('edition') // truem.has('years') // falsem.has(262) // truem.has(undefined) // true delete(key)123456const m = new Map();m.set(undefined, 'nah');m.has(undefined) // truem.delete(undefined)m.has(undefined) // false clear()clear all elements, no return value1234567let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2map.clear()map.size // 0 override:1234567const map = new Map();map.set(1, 'aaa').set(1, 'bbb');map.get(1) // "bbb" ConvertConvert Map to Array:12345const myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] Convert Array to Map:12345678new Map([[true, 7],[&#123;foo: 3&#125;, ['abc']]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; ['abc']// &#125; Convert Map to Object:If keys for map are all strings, the convertion is accepted.12345678910111213function strMapToObj(strMap) &#123;let obj = Object.create(null);for (let [k,v] of strMap) &#123;obj[k] = v;&#125;return obj;&#125;const myMap = new Map().set('yes', true).set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; Convert Object to Map:12345678910function objToStrMap(obj) &#123;let strMap = new Map();for (let k of Object.keys(obj)) &#123;strMap.set(k, obj[k]);&#125;return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;"yes" =&gt; true, "no" =&gt; false&#125; Convert Map to JSON:(1) Keys are stings1234567function strMapToJson(strMap) &#123;return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;"yes":true,"no":false&#125;' (2)Keys contain non string1234567function mapToArrayJson(map) &#123;return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]' Convert JSON to Map:123456function jsonToStrMap(jsonStr) &#123;return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap('&#123;"yes": true, "no": false&#125;')// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125; Differences between Object and Map object has a prototype so there are default keys can be bypassed using map = Object.create(null) object keys are string whereas map keys can be anything map keeps track of size use maps over objects when keys are unknown until run time use objects when there is logic that operates on individual elements WeakSet iterate through providing keys only not enumerable unique object references only accept objects Differences between Set and WeakSet WeakSets are collections of object types only references to objects in the collection are held weakly 123456789var myWeakSet = new WeakSet();var foo = &#123;&#125;;var bar = &#123;&#125;;myWeakSet.add(foo);myWeakSet.has(bar); // falsemyWeakSet.has(foo); // truemyWeakSet.delete(foo);myWeakSet.add(&#123; kobe: 24 &#125;); // But because the added object has no other references, it will not be held in the set WeakMap iterate through providing keys only not enumerable unique object or function references does not accept primitive data types as keys 12345678var myWeakMap = new WeakMap();var obj1 = &#123;&#125;;var obj2 = function()&#123;&#125;;myWeakMap.set(obj1, "cat");myWeakMap.set(obj2, 24);myWeakMap.has(obj1); // truemyWeakMap.get(obj2); // 24myWeakMap.delete(obj1);]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6 features (2)]]></title>
    <url>%2F2018%2F01%2F28%2FECMAScript-6-2%2F</url>
    <content type="text"><![CDATA[FunctionDefault Parameter ValuesSimple and intuitive default values for function parameters. 1234function f (x, y = 7, z = 42) &#123;return x + y + z&#125;f(1) === 50 Rest ParameterAggregation of remaining arguments into single parameter of variadic functions. 1234function f (x, y, ...a) &#123;return (x + y) * a.length&#125;f(1, 2, "hello", true, 7) === 9 Spread OperatorSpreading of elements of an iterable collection (like an array or even a string) into both literal elements and individual function parameters. 12345678910var params = [ "hello", true, 7 ]var other = [ 1, 2, ...params ] // [ 1, 2, "hello", true, 7 ]function f (x, y, ...a) &#123;return (x + y) * a.length&#125;f(1, 2, ...params) === 9var str = "foo"var chars = [ ...str ] // [ "f", "o", "o" ] Strict modeSince ES5, strict mode could be applied within function.In ES6, if a function uses default parameter value, rest parameter or spread operator, strict mode couldnâ€™t be used in the function. Name 12function foo() &#123;&#125;foo.name // "foo" Arrow Functions1var f = v =&gt; v; equals: 123var f = function(v) &#123;return v;&#125;; If there is no arguments or more than 1 arguments, use bracket. 123456789var f = () =&gt; 5;// equalsvar f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// equalsvar sum = function(num1, num2) &#123;return num1 + num2;&#125;; Example of arrow function combining with rest parameters: 123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] Tail CallDefinition: call one function at the last step of another function.123function f(x)&#123;return g(x);&#125; Tail Recursion A recursive function is tail recursive when recursive call is the last thing executed by the function. 123456function factorial(n, total) &#123;if (n === 1) return total;return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 The tail recursive functions considered better than non tail recursive functions as tail-recursion can be optimized by compiler. The idea used by compilers to optimize tail-recursive functions is simple, since the recursive call is the last statement, there is nothing left to do in the current function, so saving the current functionâ€™s stack frame is of no use (See this for more details). Example: (Fibonacci) Non tail recursive: 123456789function Fibonacci (n) &#123;if ( n &lt;= 1 ) &#123;return 1&#125;;return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // overflowFibonacci(500) // overflow Tail recursive: 123456789function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;if( n &lt;= 1 ) &#123;return ac2&#125;;return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6 features (1)]]></title>
    <url>%2F2018%2F01%2F28%2FECMAScript-6-1%2F</url>
    <content type="text"><![CDATA[constSupport for constants, variables which cannot be re-assigned new content. Notice: this only makes the variable itself immutable, not its assigned content (for instance, in case the content is an object, this means the object itself can still be altered). 12345678const foo = &#123;&#125;;// add an attribute to foo, successfoo.prop = 123;foo.prop // 123// assign foo to another object, errorfoo = &#123;&#125;; // TypeError: "foo" is read-only letBlock-scoped variables (and constants) without hoisting. â€˜letâ€™ only validates in scope: 123456789101112131415&#123;let a = 10;var b = 1;&#125;a // ReferenceError: a is not defined.b // 1which is useful in for loop:for (let i = 0; i &lt; 10; i++) &#123;// ...&#125;console.log(i);// ReferenceError: i is not defined Temporal dead zone (TDZ)If a variable is declared by â€˜letâ€™ in a block scope, itâ€™s binding to the block scope and refrain from outside. 1234567891011if (true) &#123;// TDZ starttmp = 'abc'; // ReferenceErrorconsole.log(tmp); // ReferenceErrorlet tmp; // TDZ endconsole.log(tmp); // undefinedtmp = 123;console.log(tmp); // 123&#125; Repeat declaration is not allowed 1234567891011// errorfunction func() &#123;let a = 10;var a = 1;&#125;// errorfunction func() &#123;let a = 10;let a = 1;&#125; ES6 has 6 methods of variable declarationES5 has two methods of variable declaration: var, function;ES6 has 4 more methods: let, const, import, class.]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello world]]></title>
    <url>%2F2018%2F01%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello world This website is Yu Liuâ€™s homepage, built by Hexo+Github pages. Contents are written with Markdown syntax. This website is for: 1. Share idea â€œDo not go gentle into that good nightâ€ 2. Code review1234567@requires_authorizationclass SomeClass:passif __name__ == '__main__':# A commentprint 'hello world' 3. Photography 4. Schedule and plan Set up TensorFlow environment Build personal website Solve algorithm problems Learn ASP.NET MVC Framework]]></content>
      <categories>
        <category>Documentation</category>
      </categories>
  </entry>
</search>
