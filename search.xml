<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DevOps Introduction]]></title>
    <url>%2F2018%2F02%2F15%2FDevOps-Introduction%2F</url>
    <content type="text"></content>
      <categories>
        <category>software development</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrum Introduction]]></title>
    <url>%2F2018%2F02%2F14%2FScrum-Introduction%2F</url>
    <content type="text"><![CDATA[Definition of ScrumScrum (n): A framework within which people can address complex adaptive problems, while productively and creatively delivering products of the highest possible value. Scrum is:• Lightweight• Simple to understand• Difficult to master Uses of Scrum Research and identify viable markets, technologies, and product capabilities; Develop products and enhancements; Release products and enhancements, as frequently as many times per day; Develop and sustain Cloud (online, secure, on-demand) and other operationalenvironments for product use; and, Sustain and renew products. Scrum TheoryScrum is founded on empirical process control theory, or empiricism. Empiricism asserts that knowledge comes from experience and making decisions based on what is known. Scrum employs an iterative, incremental approach to optimize predictability and control risk. Three pillars uphold every implementation of empirical process control:transparency, inspection, and adaptation. TransparencySignificant aspects of the process must be visible to those responsible for the outcome. Transparency requires those aspects be defined by a common standard so observers share a common understanding of what is being seen. For example: • A common language referring to the process must be shared by all participants; and,• Those performing the work and those inspecting the resulting increment must share a common definition of “Done”. InspectionScrum users must frequently inspect Scrum artifacts and progress toward a Sprint Goal to detect undesirable variances. Their inspection should not be so frequent that inspection gets in the way of the work. Inspections are most beneficial when diligently performed by skilled inspectors at the point of work. AdaptationIf an inspector determines that one or more aspects of a process deviate outside acceptable limits, and that the resulting product will be unacceptable, the process or the material being processed must be adjusted. An adjustment must be made as soon as possible to minimize further deviation. Scrum prescribes four formal events for inspection and adaptation, as described in the Scrum Events section of this document: • Sprint Planning• Daily Scrum• Sprint Review• Sprint Retrospective The Scrum TeamThe Scrum Team consists of a Product Owner, the Development Team, and a Scrum Master. Scrum Teams are self-organizing and cross-functional. Self-organizing teams choose how best to accomplish their work, rather than being directed by others outside the team. Cross-functional teams have all competencies needed to accomplish the work without depending on others not part of the team. The team model in Scrum is designed to optimize flexibility, creativity, and productivity. The Product OwnerThe Product Owner is responsible for maximizing the value of the product resulting from work of the Development Team. How this is done may vary widely across organizations, Scrum Teams, and individuals. The Product Owner is the sole person responsible for managing the Product Backlog. Product Backlog management includes: • Clearly expressing Product Backlog items;• Ordering the items in the Product Backlog to best achieve goals and missions;• Optimizing the value of the work the Development Team performs;• Ensuring that the Product Backlog is visible, transparent, and clear to all, and shows what the Scrum Team will work on next;• Ensuring the Development Team understands items in the Product Backlog to the level needed. The Product Owner may do the above work, or have the Development Team do it. However, the Product Owner remains accountable. The Product Owner is one person, not a committee. The Product Owner may represent the desires of a committee in the Product Backlog, but those wanting to change a Product Backlog item’s priority must address the Product Owner. For the Product Owner to succeed, the entire organization must respect his or her decisions. The Product Owner’s decisions are visible in the content and ordering of the Product Backlog. No one can force the Development Team to work from a different set of requirements. The Development TeamThe Development Team consists of professionals who do the work of delivering a potentially releasable Increment of “Done” product at the end of each Sprint. A “Done” increment is required at the Sprint Review. Only members of the Development Team create the Increment. Development Teams are structured and empowered by the organization to organize and manage their own work. The resulting synergy optimizes the Development Team’s overall efficiency and effectiveness. Development Teams have the following characteristics: • They are self-organizing. No one (not even the Scrum Master) tells the Development Team how to turn Product Backlog into Increments of potentially releasable functionality;• Development Teams are cross-functional, with all the skills as a team necessary to create a product Increment;• Scrum recognizes no titles for Development Team members, regardless of the work being performed by the person;• Scrum recognizes no sub-teams in the Development Team, regardless of domains that need to be addressed like testing, architecture, operations, or business analysis;• Individual Development Team members may have specialized skills and areas of focus, but accountability belongs to the Development Team as a whole. Development Team SizeOptimal Development Team size is small enough to remain nimble and large enough to complete significant work within a Sprint. Fewer than three Development Team members decrease interaction and results in smaller productivity gains. Smaller Development Teams may encounter skill constraints during the Sprint, causing the Development Team to be unable to deliver a potentially releasable Increment. Having more than nine members requires too much coordination. Large Development Teams generate too much complexity for an empirical process to be useful. The Product Owner and Scrum Master roles are not included in this count unless they are also executing the work of the Sprint Backlog. The Scrum MasterThe Scrum Master is responsible for promoting and supporting Scrum as defined in the Scrum Guide. Scrum Masters do this by helping everyone understand Scrum theory, practices, rules, and values. The Scrum Master is a servant-leader for the Scrum Team. The Scrum Master helps those outside the Scrum Team understand which of their interactions with the Scrum Team are helpful and which aren’t. The Scrum Master helps everyone change these interactions to maximize the value created by the Scrum Team. Scrum Master Service to the Product OwnerThe Scrum Master serves the Product Owner in several ways, including:• Ensuring that goals, scope, and product domain are understood by everyone on the ScrumTeam as well as possible;• Finding techniques for effective Product Backlog management;• Helping the Scrum Team understand the need for clear and concise Product Backlog items;• Understanding product planning in an empirical environment;• Ensuring the Product Owner knows how to arrange the Product Backlog to maximize value;• Understanding and practicing agility;• Facilitating Scrum events as requested or needed. Scrum Master Service to the Development TeamThe Scrum Master serves the Development Team in several ways, including:• Coaching the Development Team in self-organization and cross-functionality;• Helping the Development Team to create high-value products;• Removing impediments to the Development Team’s progress;• Facilitating Scrum events as requested or needed;• Coaching the Development Team in organizational environments in which Scrum is not yet fully adopted and understood. Scrum Master Service to the OrganizationThe Scrum Master serves the organization in several ways, including:• Leading and coaching the organization in its Scrum adoption;• Planning Scrum implementations within the organization;• Helping employees and stakeholders understand and enact Scrum and empirical productdevelopment;• Causing change that increases the productivity of the Scrum Team;• Working with other Scrum Masters to increase the effectiveness of the application of Scrum in the organization. Scrum EventsPrescribed events are used in Scrum to create regularity and to minimize the need for meetings not defined in Scrum. All events are time-boxed events, such that every event has a maximum duration. Once a Sprint begins, its duration is fixed and cannot be shortened or lengthened. The remaining events may end whenever the purpose of the event is achieved, ensuring an appropriate amount of time is spent without allowing waste in the process. The Scrum Events are: Sprint Sprint Planning Daily Scrum Sprint Review Sprint Retrospective The SprintThe heart of Scrum is a Sprint, a time-box of one month or less during which a “Done”, useable, and potentially releasable product Increment is created. Sprints have consistent durations throughout a development effort. A new Sprint starts immediately after the conclusion of theprevious Sprint. During the Sprint:• No changes are made that would endanger the Sprint Goal;• Quality goals do not decrease;• Scope may be clarified and re-negotiated between the Product Owner and Development Team as more is learned. Each Sprint may be considered a project with no more than a one-month horizon. Like projects, Sprints are used to accomplish something. Each Sprint has a goal of what is to be built, a design and flexible plan that will guide building it, the work, and the resultant product increment. Sprints are limited to one calendar month. When a Sprint’s horizon is too long the definition of what is being built may change, complexity may rise, and risk may increase. Sprints enable predictability by ensuring inspection and adaptation of progress toward a Sprint Goal at least every calendar month. Sprints also limit risk to one calendar month of cost. Sprint PlanningThe work to be performed in the Sprint is planned at the Sprint Planning. This plan is created by the collaborative work of the entire Scrum Team. Sprint Planning is time-boxed to a maximum of eight hours for a one-month Sprint. For shorter Sprints, the event is usually shorter. The Scrum Master ensures that the event takes place and that attendants understand its purpose. The Scrum Master teaches the Scrum Team to keep it within the time-box. Sprint Planning answers the following:• What can be delivered in the Increment resulting from the upcoming Sprint?• How will the work needed to deliver the Increment be achieved? Topic One: What can be done this Sprint?The Development Team works to forecast the functionality that will be developed during the Sprint. The Product Owner discusses the objective that the Sprint should achieve and the Product Backlog items that, if completed in the Sprint, would achieve the Sprint Goal. The entire Scrum Team collaborates on understanding the work of the Sprint. Topic Two: How will the chosen work get done?Having set the Sprint Goal and selected the Product Backlog items for the Sprint, the Development Team decides how it will build this functionality into a “Done” product Increment during the Sprint. The Product Backlog items selected for this Sprint plus the plan for delivering them is called the Sprint Backlog. By the end of the Sprint Planning, the Development Team should be able to explain to the Product Owner and Scrum Master how it intends to work as a self-organizing team to accomplish the Sprint Goal and create the anticipated Increment. Sprint GoalThe Sprint Goal is an objective set for the Sprint that can be met through the implementation of Product Backlog. It provides guidance to the Development Team on why it is building the Increment. It is created during the Sprint Planning meeting. The Sprint Goal gives the Development Team some flexibility regarding the functionality implemented within the Sprint. Daily ScrumThe Daily Scrum is a 15-minute time-boxed event for the Development Team. The Daily Scrum is held every day of the Sprint. At it, the Development Team plans work for the next 24 hours. This optimizes team collaboration and performance by inspecting the work since the last Daily Scrum and forecasting upcoming Sprint work. The Daily Scrum is held at the same time and place each day to reduce complexity. Sprint ReviewA Sprint Review is held at the end of the Sprint to inspect the Increment and adapt the Product Backlog if needed. During the Sprint Review, the Scrum Team and stakeholders collaborate about what was done in the Sprint. The Sprint Review includes the following elements:• Attendees include the Scrum Team and key stakeholders invited by the Product Owner;• The Product Owner explains what Product Backlog items have been “Done” and what has not been “Done”;• The Development Team discusses what went well during the Sprint, what problems it ran into, and how those problems were solved;• The Development Team demonstrates the work that it has “Done” and answers questions about the Increment;• The Product Owner discusses the Product Backlog as it stands. He or she projects likely target and delivery dates based on progress to date (if needed);• The entire group collaborates on what to do next, so that the Sprint Review provides valuable input to subsequent Sprint Planning;• Review of how the marketplace or potential use of the product might have changed what is the most valuable thing to do next;• Review of the timeline, budget, potential capabilities, and marketplace for the next anticipated releases of functionality or capability of the product. The result of the Sprint Review is a revised Product Backlog that defines the probable ProductBacklog items for the next Sprint. The Product Backlog may also be adjusted overall to meet newopportunities. Sprint RetrospectiveThe Sprint Retrospective is an opportunity for the Scrum Team to inspect itself and create a plan for improvements to be enacted during the next Sprint. The purpose of the Sprint Retrospective is to:• Inspect how the last Sprint went with regards to people, relationships, process, and tools;• Identify and order the major items that went well and potential improvements;• Create a plan for implementing improvements to the way the Scrum Team does its work. Scrum ArtifactsScrum’s artifacts represent work or value to provide transparency and opportunities for inspection and adaptation. Artifacts defined by Scrum are specifically designed to maximize transparency of key information so that everybody has the same understanding of the artifact. The Scrum Artifacts are: Product Backlog Sprint Backlog Increment Referenceswhat-is-scrum2017-Scrum-Guide]]></content>
      <categories>
        <category>software development</category>
      </categories>
      <tags>
        <tag>Scrum</tag>
        <tag>Agile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINQ Tutorial]]></title>
    <url>%2F2018%2F02%2F14%2FLINQ%2F</url>
    <content type="text"><![CDATA[OverviewLanguage Integrated Query (LINQ, pronounced “link”) is a Microsoft .NET Framework component that adds native data querying capabilities to .NET languages. All LINQ query operations consist of three distinct actions: Obtain the data source. Create the query. Execute the query. The following example shows how the three parts of a query operation are expressed in source code:12345678910111213141516171819202122class IntroToLINQ&#123; static void Main() &#123; // The Three Parts of a LINQ Query: // 1. Data source. int[] numbers = new int[7] &#123; 0, 1, 2, 3, 4, 5, 6 &#125;; // 2. Query creation. // numQuery is an IEnumerable&lt;int&gt; var numQuery = from num in numbers where (num % 2) == 0 select num; // 3. Query execution. foreach (int num in numQuery) &#123; Console.Write("&#123;0,1&#125; ", num); &#125; &#125;&#125; The following illustration shows the complete query operation. In LINQ the execution of the query is distinct from the query itself; in other words you have not retrieved any data just by creating a query variable. Why LINQIn terms of why we should use LINQ, we can explain it by an example: to find a student object in a student array. Before C# 2.0, we could find specific object in array only by using like “foreach” or “for”. For example: 1234567891011121314151617181920212223242526272829303132333435class Student&#123;public int StudentID &#123; get; set; &#125;public String StudentName &#123; get; set; &#125;public int Age &#123; get; set; &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Student[] studentArray = &#123; new Student() &#123; StudentID = 1, StudentName = "John", Age = 18 &#125;, new Student() &#123; StudentID = 2, StudentName = "Steve", Age = 21 &#125;, new Student() &#123; StudentID = 3, StudentName = "Bill", Age = 25 &#125;, new Student() &#123; StudentID = 4, StudentName = "Ram" , Age = 20 &#125;, new Student() &#123; StudentID = 5, StudentName = "Ron" , Age = 31 &#125;, new Student() &#123; StudentID = 6, StudentName = "Chris", Age = 17 &#125;, new Student() &#123; StudentID = 7, StudentName = "Rob",Age = 19 &#125;, &#125;; Student[] students = new Student[10]; int i = 0; foreach (Student std in studentArray) &#123; if (std.Age &gt; 12 &amp;&amp; std.Age &lt; 20) &#123; students[i] = std; i++; &#125; &#125; &#125;&#125; To increase readability and maintainability, in C# 2.0 delegate was imported:123456789101112131415161718192021222324252627282930313233343536373839delegate bool FindStudent(Student std);class StudentExtension&#123; public static Student[] where(Student[] stdArray, FindStudent del) &#123; int i=0; Student[] result = new Student[10]; foreach (Student std in stdArray) if (del(std)) &#123; result[i] = std; i++; &#125; return result; &#125;&#125; class Program &#123; static void Main(string[] args) &#123; Student[] studentArray = &#123; new Student() &#123; StudentID = 1, StudentName = "John", Age = 18 &#125; , new Student() &#123; StudentID = 2, StudentName = "Steve", Age = 21 &#125; , new Student() &#123; StudentID = 3, StudentName = "Bill", Age = 25 &#125; , new Student() &#123; StudentID = 4, StudentName = "Ram" , Age = 20 &#125; , new Student() &#123; StudentID = 5, StudentName = "Ron" , Age = 31 &#125; , new Student() &#123; StudentID = 6, StudentName = "Chris", Age = 17 &#125; , new Student() &#123; StudentID = 7, StudentName = "Rob",Age = 19 &#125; , &#125;; Student[] students = StudentExtension.where(studentArray, delegate(Student std)&#123; return std.Age &gt; 12 &amp;&amp; std.Age &lt; 20; &#125;); &#125; &#125;&#125; Thus, if we want to find students with different names, we can reuse the delegate instead of using different for-loop. However, C# code could be more compact and readable. LINQ was imported in C# 3.0. For example:123456789101112131415161718192021222324class Program&#123; static void Main(string[] args) &#123; Student[] studentArray = &#123; new Student() &#123; StudentID = 1, StudentName = "John", age = 18 &#125; , new Student() &#123; StudentID = 2, StudentName = "Steve", age = 21 &#125; , new Student() &#123; StudentID = 3, StudentName = "Bill", age = 25 &#125; , new Student() &#123; StudentID = 4, StudentName = "Ram" , age = 20 &#125; , new Student() &#123; StudentID = 5, StudentName = "Ron" , age = 31 &#125; , new Student() &#123; StudentID = 6, StudentName = "Chris", age = 17 &#125; , new Student() &#123; StudentID = 7, StudentName = "Rob",age = 19 &#125; , &#125;; // Use LINQ to find teenager students Student[] teenAgerStudents = studentArray.Where(s =&gt; s.age &gt; 12 &amp;&amp; s.age &lt; 20).ToArray(); // Use LINQ to find first student whose name is Bill Student bill = studentArray.Where(s =&gt; s.StudentName == "Bill").FirstOrDefault(); // Use LINQ to find student whose StudentID is 5 Student student5 = studentArray.Where(s =&gt; s.StudentID == 5).FirstOrDefault(); &#125;&#125; Syntax of LINQThere are two syntaxes of LINQ. These are the following ones. Lamda (Method) Syntax12var longWords = words.Where( w ⇒ w.length &gt; 10);Dim longWords = words.Where(Function(w) w.length &gt; 10) Query (Comprehension) Syntax12var longwords = from w in words where w.length &gt; 10;Dim longwords = from w in words where w.length &gt; 10 Types of LINQThe types of LINQ are mentioned below in brief. LINQ to Objects LINQ to XML(XLINQ) LINQ to DataSet LINQ to SQL (DLINQ) LINQ to Entities Walkthrough: Writing Queries in C# (LINQ)This walkthrough demonstrates the C# language features that are used to write LINQ query expressions. Create a C# ProjectTo create a project in Visual Studio Start Visual Studio. On the menu bar, choose File, New, Project.The New Project dialog box opens. Expand Installed, expand Templates, expand Visual C#, and then choose Console Application. In the Name text box, enter a different name or accept the default name, and then choose the OK button.The new project appears in Solution Explorer. Notice that your project has a reference to System.Core.dll and a using directive for the System.Linq namespace. Create an in-Memory Data Source To add the data sourceAdd the Student class and the initialized list of students to the Program class in your project. 123456789101112131415public class Student&#123; public string First &#123; get; set; &#125; public string Last &#123; get; set; &#125; public int ID &#123; get; set; &#125; public List&lt;int&gt; Scores;&#125;// Create a data source by using a collection initializer.static List&lt;Student&gt; students = new List&lt;Student&gt;&#123; new Student &#123;First="Svetlana", Last="Omelchenko", ID=111, Scores= new List&lt;int&gt; &#123;97, 92, 81, 60&#125;&#125;, new Student &#123;First="Claire", Last="O'Donnell", ID=112, Scores= new List&lt;int&gt; &#123;75, 84, 91, 39&#125;&#125;, new Student &#123;First="Sven", Last="Mortensen", ID=113, Scores= new List&lt;int&gt; &#123;88, 94, 65, 91&#125;&#125;,&#125;; To add a new Student to the Students listAdd a new Student to the Students list and use a name and test scores of your choice. Try typing all the new student information in order to better learn the syntax for the object initializer. Create the Query To create a simple queryIn the application’s Main method, create a simple query that, when it is executed, will produce a list of all students whose score on the first test was greater than 90.123456// Create the query.// The first line could also be written as "var studentQuery ="IEnumerable&lt;Student&gt; studentQuery = from student in students where student.Scores[0] &gt; 90 select student; Execute the Query To execute the query Now write the foreach loop that will cause the query to execute. Note the following about the code: Each element in the returned sequence is accessed through the iteration variable in the foreach loop. The type of this variable is Student, and the type of the query variable is compatible, IEnumerable. After you have added this code, build and run the application to see the results in the Console window. 123456// Execute the query.// var could be used here also.foreach (Student student in studentQuery)&#123; Console.WriteLine("&#123;0&#125;, &#123;1&#125;", student.Last, student.First);&#125; To add another filter conditionYou can combine multiple Boolean conditions in the where clause in order to further refine a query. 1where student.Scores[0] &gt; 90 &amp;&amp; student.Scores[3] &lt; 80 Modify the QueryTo order the resultsYou can order the returned sequence by any accessible field in the source elements.1orderby student.Last ascending To group the results Grouping is a powerful capability in query expressions. A query with a group clause produces a sequence of groups, and each group itself contains a Key and a sequence that consists of all the members of that group.The following new query groups the students by using the first letter of their last name as the key. 1234// studentQuery2 is an IEnumerable&lt;IGrouping&lt;char, Student&gt;&gt;var studentQuery2 = from student in students group student by student.Last[0]; Note that the type of the query has now changed. It now produces a sequence of groups that have a char type as a key, and a sequence of Student objects. 12345678910// studentGroup is a IGrouping&lt;char, Student&gt;foreach (var studentGroup in studentQuery2)&#123; Console.WriteLine(studentGroup.Key); foreach (Student student in studentGroup) &#123; Console.WriteLine(" &#123;0&#125;, &#123;1&#125;", student.Last, student.First); &#125;&#125; To make the variables implicitly typedYou can write the same query and foreach loop much more conveniently by using var. The var keyword does not change the types of your objects; it just instructs the compiler to infer the types.Note that in the inner foreach loop, the iteration variable is still typed as Student, and the query works just as before.12345678910111213var studentQuery3 = from student in students group student by student.Last[0];foreach (var groupOfStudents in studentQuery3)&#123; Console.WriteLine(groupOfStudents.Key); foreach (var student in groupOfStudents) &#123; Console.WriteLine(" &#123;0&#125;, &#123;1&#125;", student.Last, student.First); &#125;&#125; To order the groups by their key valueWhen you run the previous query, you notice that the groups are not in alphabetical order. To change this, you must provide an orderby clause after the group clause.But to use an orderby clause, you first need an identifier that serves as a reference to the groups created by the group clause. You provide the identifier by using the into keyword, as follows:123456789101112131415var studentQuery4 = from student in students group student by student.Last[0] into studentGroup orderby studentGroup.Key select studentGroup;foreach (var groupOfStudents in studentQuery4)&#123; Console.WriteLine(groupOfStudents.Key); foreach (var student in groupOfStudents) &#123; Console.WriteLine(" &#123;0&#125;, &#123;1&#125;", student.Last, student.First); &#125;&#125; To introduce an identifier by using letYou can use the let keyword to introduce an identifier for any expression result in the query expression. This identifier can be a convenience, as in the following example, or it can enhance performance by storing the results of an expression so that it does not have to be calculated multiple times.123456789101112131415// studentQuery5 is an IEnumerable&lt;string&gt;// This query returns those students whose// first test score was higher than their// average score.var studentQuery5 = from student in students let totalScore = student.Scores[0] + student.Scores[1] + student.Scores[2] + student.Scores[3] where totalScore / 4 &lt; student.Scores[0] select student.Last + " " + student.First;foreach (string s in studentQuery5)&#123; Console.WriteLine(s);&#125; To use method syntax in a query expressionThe following code calculates the total score for each Student in the source sequence, and then calls the Average() method on the results of that query to calculate the average score of the class.1234567891011var studentQuery6 = from student in students let totalScore = student.Scores[0] + student.Scores[1] + student.Scores[2] + student.Scores[3] select totalScore;double averageScore = studentQuery6.Average();Console.WriteLine("Class average score = &#123;0&#125;", averageScore);// Output:// Class average score = 334.166666666667 To transform or project in the select clause It is very common for a query to produce a sequence whose elements differ from the elements in the source sequences. Delete or comment out your previous query and execution loop, and replace it with the following code. Note that the query returns a sequence of strings (not Students), and this fact is reflected in the foreach loop. 12345678910IEnumerable&lt;string&gt; studentQuery7 = from student in students where student.Last == "Garcia" select student.First;Console.WriteLine("The Garcias in the class are:");foreach (string s in studentQuery7)&#123; Console.WriteLine(s);&#125; Code earlier in this walkthrough indicated that the average class score is approximately 334. To produce a sequence of Students whose total score is greater than the class average, together with their Student ID, you can use an anonymous type in the select statement: 1234567891011var studentQuery8 = from student in students let x = student.Scores[0] + student.Scores[1] + student.Scores[2] + student.Scores[3] where x &gt; averageScore select new &#123; id = student.ID, score = x &#125;;foreach (var item in studentQuery8)&#123; Console.WriteLine("Student ID: &#123;0&#125;, Score: &#123;1&#125;", item.id, item.score);&#125; ReferencesLanguage Integrated QueryLINQ FundamentalLINQ TutorialGetting Started with LINQ in C#]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>LINQ</tag>
        <tag>C#</tag>
        <tag>ASP.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket Tutorial]]></title>
    <url>%2F2018%2F02%2F12%2FWebSocket%2F</url>
    <content type="text"><![CDATA[Why WebSocketMany people might have the doubt, why do we need WebSocket when we already have HTTP protocal. The answer is simple: with HTTP communication could only be initiated by client. For example, if we want to know about the weather today, we can only send request from client to server, then the server responses with the search result. It’s not applicable for server to push information to client automatically. Under the condition that client need the real-time status of server, it would be difficult for traditional HTTP protocal to achieve that. One commonly used solution is called polling. But polling is inefficient which creates a large amount of requests. Thus, WebSocket is created to solve the problem above. OverviewWeb Sockets is a next-generation bidirectional communication technology for web applications which operates over a single socket and is exposed via a JavaScript interface in HTML 5 compliant browsers. Once you get a Web Socket connection with the web server, you can send data from browser to server by calling a send() method, and receive data from server to browser by an onmessage event handler. Following is the API which creates a new WebSocket object. 1var Socket = new WebSocket(url, [protocal] ); Here first argument, url, specifies the URL to which to connect. The second attribute, protocol is optional, and if present, specifies a sub-protocol that the server must support for the connection to be successful. WebSocket AttributesFollowing are the attribute of WebSocket object. Assuming we created Socket object as mentioned above − Attribute Description Socket.readyState The readonly attribute readyState represents the state of the connection. It can have the following values:A value of 0 indicates that the connection has not yet been established.A value of 1 indicates that the connection is established and communication is possible. A value of 2 indicates that the connection is going through the closing handshake. A value of 3 indicates that the connection has been closed or could not be opened. Socket.bufferedAmount The readonly attribute bufferedAmount represents the number of bytes of UTF-8 text that have been queued using send() method. WebSocket EventsFollowing are the events associated with WebSocket object. Assuming we created Socket object as mentioned above: Event Event Handler Description open Socket.onopen This event occurs when socket connection is established. message Socket.onmessage This event occurs when client receives data from server. error Socket.onerror This event occurs when there is any error in communication. close Socket.onclose This event occurs when connection is closed. WebSocket MethodsFollowing are the methods associated with WebSocket object. Assuming we created Socket object as mentioned above: Method Description Socket.send() The send(data) method transmits data using the connection. Socket.close() The close() method would be used to terminate any existing connection. WebSocket ExampleA WebSocket is a standard bidirectional TCP socket between the client and the server. The socket starts out as a HTTP connection and then “Upgrades” to a TCP socket after a HTTP handshake. After the handshake, either side can send data. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;script type="text/javascript"&gt;function WebSocketTest()&#123;if ("WebSocket" in window)&#123;alert("WebSocket is supported by your Browser!");// Let us open a web socketvar ws = new WebSocket("ws://localhost:9998/echo");ws.onopen = function()&#123;// Web Socket is connected, send data using send()ws.send("Message to send");alert("Message is sent...");&#125;;ws.onmessage = function (evt)&#123;var received_msg = evt.data;alert("Message is received...");&#125;;ws.onclose = function()&#123;// websocket is closed.alert("Connection is closed...");&#125;;window.onbeforeunload = function(event) &#123;socket.close();&#125;;&#125;else&#123;// The browser doesn't support WebSocketalert("WebSocket NOT supported by your Browser!");&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="sse"&gt;&lt;a href="javascript:WebSocketTest()"&gt;Run WebSocket&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ReferencesIntroducing WebSockets: Bringing Sockets to the WebWebSockets - Send &amp; Receive MessagesHTML5 - WebSocketsPush technologyWebSockets vs REST: Understanding the DifferenceWebSockets Tutorial]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Building a cat classifier with logistic regression from scratch]]></title>
    <url>%2F2018%2F02%2F09%2Fbuilding-a-cat-classifier-with-logistic-regression%2F</url>
    <content type="text"><![CDATA[GoalBuild the general architecture of a learning algorithm, including: Initializing parameters Calculating the cost function and its gradient Using an optimization algorithm (gradient descent) Gather all three functions above into a main model function, in the right order. PackagesFirst, let’s run the cell below to import all the packages. numpy is the fundamental package for scientific computing with Python. h5py is a common package to interact with a dataset that is stored on an H5 file. matplotlib is a famous library to plot graphs in Python. PIL and scipy are used here to test your model with your own picture at the end. 123456789import numpy as npimport matplotlib.pyplot as pltimport h5pyimport scipyfrom PIL import Imagefrom scipy import ndimagefrom lr_utils import load_dataset%matplotlib inline Overview of the Problem setThe dataset we will use contains: a training set of m_train images labeled as cat (y=1) or non-cat (y=0) a test set of m_test images labeled as cat or non-cat each image is of shape (num_px, num_px, 3) where 3 is for the 3 channels (RGB). Thus, each image is square (height = num_px) and (width = num_px). First we import the data from file 12# Loading the data (cat/non-cat)train_set_x_orig, train_set_y, test_set_x_orig, test_set_y Now we show information of data, each image is of shape (64, 64, 3) showing it’s 64*64, RGB. 12345678print ("Number of training examples: m_train = " + str(m_train))print ("Number of testing examples: m_test = " + str(m_test))print ("Height/Width of each image: num_px = " + str(num_px))print ("Each image is of size: (" + str(num_px) + ", " + str(num_px) + ", 3)")print ("train_set_x shape: " + str(train_set_x_orig.shape))print ("train_set_y shape: " + str(train_set_y.shape))print ("test_set_x shape: " + str(test_set_x_orig.shape))print ("test_set_y shape: " + str(test_set_y.shape)) Output:Number of training examples: m_train = 209Number of testing examples: m_test = 50Height/Width of each image: num_px = 64Each image is of size: (64, 64, 3)train_set_x shape: (209, 64, 64, 3)train_set_y shape: (1, 209)test_set_x shape: (50, 64, 64, 3)test_set_y shape: (1, 50) Then we reshape the training and test dataset to column vector:1234print ("train_set_x_flatten shape: " + str(train_set_x_flatten.shape))print ("train_set_y shape: " + str(train_set_y.shape))print ("test_set_x_flatten shape: " + str(test_set_x_flatten.shape))print ("test_set_y shape: " + str(test_set_y.shape)) Output:train_set_x_flatten shape: (12288, 209)train_set_y shape: (1, 209)test_set_x_flatten shape: (12288, 50)test_set_y shape: (1, 50) At last, let’s standardize our dataset:12train_set_x = train_set_x_flatten/255.test_set_x = test_set_x_flatten/255. Mathematical expression of the algorithm Step Initialize the parameters of the model Learn the parameters for the model by minimizing the cost Use the learned parameters to make predictions (on the test set) Analyse the results and conclude For one example $x^{(i)}$:$$z^{(i)} = w^T x^{(i)} + b \tag{1}$$$$\hat{y}^{(i)} = a^{(i)} = sigmoid(z^{(i)})\tag{2}$$$$ \mathcal{L}(a^{(i)}, y^{(i)}) = - y^{(i)} \log(a^{(i)}) - (1-y^{(i)} ) \log(1-a^{(i)})\tag{3}$$ The cost is then computed by summing over all training examples:$$ J = \frac{1}{m} \sum_{i=1}^m \mathcal{L}(a^{(i)}, y^{(i)})\tag{6}$$ Building the parts of our algorithm StepThe main steps for building a Neural Network are: Define the model structure (such as number of input features) Initialize the model’s parameters Loop: Calculate current loss (forward propagation) Calculate current gradient (backward propagation) Update parameters (gradient descent) Forward and Backward propagationForward Propagation: You get X You compute $A = \sigma(w^T X + b) = (a^{(0)}, a^{(1)}, …, a^{(m-1)}, a^{(m)})$ You calculate the cost function: $J = -\frac{1}{m}\sum_{i=1}^{m}y^{(i)}\log(a^{(i)})+(1-y^{(i)})\log(1-a^{(i)})$ Here are the two formulas you will be using: $$ \frac{\partial J}{\partial w} = \frac{1}{m}X(A-Y)^T$$ $$ \frac{\partial J}{\partial b} = \frac{1}{m} \sum_{i=1}^m (a^{(i)}-y^{(i)})$$ Here is the Forward-propagation function:1234567891011121314151617181920212223242526272829303132333435def propagate(w, b, X, Y):"""Implement the cost function and its gradient for the propagation explained aboveArguments:w -- weights, a numpy array of size (num_px * num_px * 3, 1)b -- bias, a scalarX -- data of size (num_px * num_px * 3, number of examples)Y -- true "label" vector (containing 0 if non-cat, 1 if cat) of size (1, number of examples)Return:cost -- negative log-likelihood cost for logistic regressiondw -- gradient of the loss with respect to w, thus same shape as wdb -- gradient of the loss with respect to b, thus same shape as b"""m = X.shape[1]# FORWARD PROPAGATION (FROM X TO COST)# compute activation (1, number of examples)A = sigmoid(np.dot(w.T, X) + b)# compute costcost = -1.0/m * np.sum(Y*np.log(A) + (1-Y)*np.log(1-A))# BACKWARD PROPAGATION (TO FIND GRAD)# compute gradientdw = 1.0/m*np.dot(X, (A-Y).T)db = 1.0/m*np.sum(A-Y)cost = np.squeeze(cost)grads = &#123;"dw": dw,"db": db&#125;return grads, cost 12345w, b, X, Y = np.array([[1.],[2.]]), 2., np.array([[1.,2.,-1.],[3.,4.,-3.2]]), np.array([[1,0,1]])grads, cost = propagate(w, b, X, Y)print (&quot;dw = &quot; + str(grads[&quot;dw&quot;]))print (&quot;db = &quot; + str(grads[&quot;db&quot;]))print (&quot;cost = &quot; + str(cost)) Output:dw = [[ 0.99845601][ 2.39507239]]db = 0.00145557813678cost = 5.80154531939 Optimization123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def optimize(w, b, X, Y, num_iterations, learning_rate, print_cost = False):&quot;&quot;&quot;This function optimizes w and b by running a gradient descent algorithmArguments:w -- weights, a numpy array of size (num_px * num_px * 3, 1)b -- bias, a scalarX -- data of shape (num_px * num_px * 3, number of examples)Y -- true &quot;label&quot; vector (containing 0 if non-cat, 1 if cat), of shape (1, number of examples)num_iterations -- number of iterations of the optimization looplearning_rate -- learning rate of the gradient descent update ruleprint_cost -- True to print the loss every 100 stepsReturns:params -- dictionary containing the weights w and bias bgrads -- dictionary containing the gradients of the weights and bias with respect to the cost functioncosts -- list of all the costs computed during the optimization, this will be used to plot the learning curve.Tips:1) Calculate the cost and the gradient for the current parameters. Use propagate().2) Update the parameters using gradient descent rule for w and b.&quot;&quot;&quot;costs = []for i in range(num_iterations):# Cost and gradient calculationgrads, cost = propagate(w, b, X, Y)# Retrieve derivatives from gradsdw = grads[&quot;dw&quot;]db = grads[&quot;db&quot;]# update rulew = w - learning_rate * dwb = b - learning_rate * db# Record the costsif i % 100 == 0:costs.append(cost)# Print the cost every 100 training examplesif print_cost and i % 100 == 0:print (&quot;Cost after iteration %i: %f&quot; %(i, cost))params = &#123;&quot;w&quot;: w,&quot;b&quot;: b&#125;grads = &#123;&quot;dw&quot;: dw,&quot;db&quot;: db&#125;return params, grads, costs 123456params, grads, costs = optimize(w, b, X, Y, num_iterations= 100, learning_rate = 0.009, print_cost = False)print (&quot;w = &quot; + str(params[&quot;w&quot;]))print (&quot;b = &quot; + str(params[&quot;b&quot;]))print (&quot;dw = &quot; + str(grads[&quot;dw&quot;]))print (&quot;db = &quot; + str(grads[&quot;db&quot;])) Output:w = [[ 0.19033591][ 0.12259159]]b = 1.92535983008dw = [[ 0.67752042][ 1.41625495]]db = 0.219194504541 Prediction123456789101112131415161718192021222324252627def predict(w, b, X):&apos;&apos;&apos;Predict whether the label is 0 or 1 using learned logistic regression parameters (w, b)Arguments:w -- weights, a numpy array of size (num_px * num_px * 3, 1)b -- bias, a scalarX -- data of size (num_px * num_px * 3, number of examples)Returns:Y_prediction -- a numpy array (vector) containing all predictions (0/1) for the examples in X&apos;&apos;&apos;m = X.shape[1]Y_prediction = np.zeros((1, m))w = w.reshape(X.shape[0], 1)# Compute vector &quot;A&quot; predicting the probabilities of a cat being present in the pictureA = sigmoid(np.dot(w.T, X) + b)for i in range(A.shape[1]):# Convert probabilities a[0,i] to actual predictions p[0,i]Y_prediction[0, i] = 1 if A[0, i] &gt; 0.5 else 0assert(Y_prediction.shape == (1, m))return Y_prediction Step1.Initialize (w,b) Optimize the loss iteratively to learn parameters (w,b): computing the cost and its gradient updating the parameters using gradient descent Use the learned (w,b) to predict the labels for a given set of examples Merge all functions Implement the model function: Y_prediction for your predictions on the test set Y_prediction_train for your predictions on the train set w, costs, grads for the outputs of optimize() 123456789101112131415161718192021222324252627282930313233343536373839404142434445def model(X_train, Y_train, X_test, Y_test, num_iterations = 2000, learning_rate = 0.5, print_cost = False):&quot;&quot;&quot;Builds the logistic regression model by calling the function implemented previouslyArguments:X_train -- training set represented by a numpy array of shape (num_px * num_px * 3, m_train)Y_train -- training labels represented by a numpy array (vector) of shape (1, m_train)X_test -- test set represented by a numpy array of shape (num_px * num_px * 3, m_test)Y_test -- test labels represented by a numpy array (vector) of shape (1, m_test)num_iterations -- hyperparameter representing the number of iterations to optimize the parameterslearning_rate -- hyperparameter representing the learning rate used in the update rule of optimize()print_cost -- Set to true to print the cost every 100 iterationsReturns:d -- dictionary containing information about the model.&quot;&quot;&quot;# initialize parameters with zerosw, b = initialize_with_zeros(X_train.shape[0])# Gradient descentparameters, grads, costs = optimize(w, b, X_train, Y_train, num_iterations, learning_rate, print_cost);# Retrieve parameters w and b from dictionary &quot;parameters&quot;w = parameters[&quot;w&quot;]b = parameters[&quot;b&quot;]# Predict test/train set examplesY_prediction_test = predict(w, b, X_test)Y_prediction_train = predict(w, b, X_train)# Print train/test Errorsprint(&quot;train accuracy: &#123;&#125; %&quot;.format(100 - np.mean(np.abs(Y_prediction_train - Y_train)) * 100))print(&quot;test accuracy: &#123;&#125; %&quot;.format(100 - np.mean(np.abs(Y_prediction_test - Y_test)) * 100))d = &#123;&quot;costs&quot;: costs,&quot;Y_prediction_test&quot;: Y_prediction_test,&quot;Y_prediction_train&quot; : Y_prediction_train,&quot;w&quot; : w,&quot;b&quot; : b,&quot;learning_rate&quot; : learning_rate,&quot;num_iterations&quot;: num_iterations&#125;return d Run the following cell to train your model.1d = model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = 2000, learning_rate = 0.005, print_cost = True) Output:Cost after iteration 0: 0.693147Cost after iteration 100: 0.584508Cost after iteration 200: 0.466949Cost after iteration 300: 0.376007Cost after iteration 400: 0.331463Cost after iteration 500: 0.303273Cost after iteration 600: 0.279880Cost after iteration 700: 0.260042Cost after iteration 800: 0.242941Cost after iteration 900: 0.228004Cost after iteration 1000: 0.214820Cost after iteration 1100: 0.203078Cost after iteration 1200: 0.192544Cost after iteration 1300: 0.183033Cost after iteration 1400: 0.174399Cost after iteration 1500: 0.166521Cost after iteration 1600: 0.159305Cost after iteration 1700: 0.152667Cost after iteration 1800: 0.146542Cost after iteration 1900: 0.140872train accuracy: 99.04306220095694 %test accuracy: 70.0 % Comment:Training accuracy is close to 100%. This is a good sanity check: your model is working and has high enough capacity to fit the training data. Test error is 68%. It is actually not bad for this simple model, given the small dataset we used and that logistic regression is a linear classifier. Also, you see that the model is clearly overfitting the training data. ReferencesNeural Networks and Deep LearningImplementing a Neural Network from Scratch in Python – An Introductionhttps://stats.stackexchange.com/questions/211436]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Machine Learning</tag>
        <tag>Logistic Regression</tag>
        <tag>Neural Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - Vectorization and Broadcasting]]></title>
    <url>%2F2018%2F02%2F08%2FPython-Broadcasting%2F</url>
    <content type="text"><![CDATA[VectorizationIn the course Neural Networks and Deep Learning, Andrew Ng introduces vetorization in machine learning by giving the following examples: 123456789101112131415161718192021222324import numpy as npimport timea = np.random.rand(1000000)b = np.random.rand(1000000)# vectorizationtic = time.time()c = np.dot(a,b)toc = time.time()print(c)print("Vectorization:" + str(1000*(toc-tic)) + "ms")c = 0# vectorizationtic = time.time()for i in range(1000000):c += a[i]*b[i]toc = time.time()print(c)print("For loop:" + str(1000*(toc-tic)) + "ms") The above code uses vetorization and for loop to do the same calculation. However, the for loop version cost much more time than the vectorization version. Output:249888.154501Vectorization:2.2249221801757812ms249888.154501For loop:599.0450382232666ms The above example indicates that in python it’s more efficient to use vectorization instead of for loop. This kind of technique is also called SIMD(single instruction multiple data) in CPU/GPU parallel processing. Broadcasting The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is “broadcast” across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. NumPy operations are usually done on pairs of arrays on an element-by-element basis. In the simplest case, the two arrays must have exactly the same shape, as in the following example: 1234&gt;&gt;&gt; a = np.array([1.0, 2.0, 3.0])&gt;&gt;&gt; b = np.array([2.0, 2.0, 2.0])&gt;&gt;&gt; a * barray([ 2., 4., 6.]) NumPy’s broadcasting rule relaxes this constraint when the arrays’ shapes meet certain constraints. The simplest broadcasting example occurs when an array and a scalar value are combined in an operation: 1234&gt;&gt;&gt; a = np.array([1.0, 2.0, 3.0])&gt;&gt;&gt; b = 2.0&gt;&gt;&gt; a * barray([ 2., 4., 6.]) The result is equivalent to the previous example where b was an array. We can think of the scalar b being stretched during the arithmetic operation into an array with the same shape as a. The new elements in b are simply copies of the original scalar. The stretching analogy is only conceptual. NumPy is smart enough to use the original scalar value without actually making copies, so that broadcasting operations are as memory and computationally efficient as possible. The code in the second example is more efficient than that in the first because broadcasting moves less memory around during the multiplication (b is a scalar rather than an array). General Broadcasting RulesWhen operating on two arrays, NumPy compares their shapes element-wise. It starts with the trailing dimensions, and works its way forward. Two dimensions are compatible when they are equal one of them is 1 Arrays don’t have to have the same number of dimensions. For example, if you have a 256x256x3 array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with 3 values. Image (3d array): 256 x 256 x 3Scale (1d array): 3Result (3d array): 256 x 256 x 3 When either of the dimensions compared is one, the other is used. In other words, dimensions with size 1 are stretched or “copied” to match the other. A (4d array): 8 x 1 x 6 x 1B (3d array): 7 x 1 x 5Result (4d array): 8 x 7 x 6 x 5 A (2d array): 5 x 4B (1d array): 1Result (2d array): 5 x 4 A (2d array): 5 x 4B (1d array): 4Result (2d array): 5 x 4 A (3d array): 15 x 3 x 5B (3d array): 15 x 1 x 5Result (3d array): 15 x 3 x 5 A (3d array): 15 x 3 x 5B (2d array): 3 x 5Result (3d array): 15 x 3 x 5 Here are examples of shapes that do not broadcast: A (1d array): 3B (1d array): 4 # trailing dimensions do not match A (2d array): 2 x 1B (3d array): 8 x 4 x 3 # second from last dimensions mismatched References Neural Networks and Deep Learning Broadcasting — NumPy v1.12 Manual]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NumPy</tag>
        <tag>vectorization</tag>
        <tag>broadcasting</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Analytics Introduction]]></title>
    <url>%2F2018%2F02%2F07%2FWeekly-Report-20180207%2F</url>
    <content type="text"><![CDATA[In order to better evaluate how the website works, I use Google Analytics to monitor statistics of the website. Here is a brief introduction of how Google Analytics works and what we can get from it. HomeIn home page there are portals to most important statistics. Real-TimeIn Real-Time page, we can monitor our website in real-time mode, which is useful for website adminstrator. In the picture we can see that there is no active users on site. AudienceIn Audience page, information of users are listed. We can see the number of users, sessions/pageviews of users and demographics of users. AquisitionIn Aquisition page, it shows how users are directed to this website, which is useful for analyzing how to get more users. BehaviorIn Behavior page, different kinds of website behaviors are presented. This section could help website administrator to evaluate the efficiency and accessibility of website. In this section I recommend Behavior Flow cause it shows how users jump between pages. ReportHere attached sample Google Analytics report for this website. Analytics Website Monitor Acquisition OverviewAnalytics Website Monitor Behavior FlowAnalytics Website Monitor LocationAnalytics Website Monitor Overview]]></content>
      <categories>
        <category>Documentation</category>
      </categories>
      <tags>
        <tag>Google Analytics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PCA - Mathematics (1)]]></title>
    <url>%2F2018%2F01%2F30%2FPCA-Mathematical-principle%2F</url>
    <content type="text"><![CDATA[Principal component analysis (PCA) is a statistical procedure that uses an orthogonal transformation to convert a set of observations of possibly correlated variables into a set of values of linearly uncorrelated variables called principal components. Vector representation and Dimensionality reduction of dataIn general, in data mining and machine learning, data are represented as vectors.For example:$$ (500,240,25,13,2312.15)^𝖳 $$ As we know, the scale of dimensionality of data is in proportion to complexity of machine learning algorithm, so we can reduce dimensionality to simplify calculation. Obviuosly, dimensionality reduction means loss of information. However, due to the correlation among data, we could minimize the loss in the above process, which is the purpose of PCA. Change of basesInner productInner product of two vectors is defined as: $$ (a_1,a_2,⋯,a_n)^𝖳⋅(b_1,b_2,⋯,b_n)^𝖳=a_1b_1+a_2b_2+⋯+a_nb_n $$ and $$ A⋅B=|A||B|cos(a) $$ Let |B| = 1, that is $ A⋅B=|A|cos(a) $. The above definition could be explained that the inner product of A and B equals the vector length projected from A to B. BaseTo describe a vector, we need a set of bases. Then the vector could be represented as the combination of projections to all bases. Usually, we choose (1,0) and (0,1) as bases, but actually we can choose any two linearly independent vectors as bases. For example, we can use $ (\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}) $ and $ (\frac{1}{\sqrt{2}}, -\frac{1}{\sqrt{2}}) $ as new bases to represent the same vector. Matrix representation of form changeFor example, we want to transform (3, 2) based on new bases $ (\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}) $ and $ (\frac{1}{\sqrt{2}}, -\frac{1}{\sqrt{2}}) $, which could be represented by the following form: $$\left(\begin{matrix}\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\-\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}}\end{matrix}\right)\left(\begin{matrix}1 &amp; 2 &amp; 3 \\1 &amp; 2 &amp; 3\end{matrix}\right)=\left(\begin{matrix}\frac{2}{\sqrt{2}} &amp; \frac{4}{\sqrt{2}} &amp; \frac{6}{\sqrt{2}} \\0 &amp; 0 &amp; 0\end{matrix}\right)$$ In general, if we have M N-dimesion vector and want to transform them into R N-dimesion new spaces, we first construct matrix A combining R bases by row, then construct matrix B combining vectors by column. The product of A and B is the result, where the column in AB is transformed from column in A. The above shows an explanation of matrix product:product of two matrices(AB) means to transform each column vector in B to the new space with rows in A as bases.]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Mathematics</tag>
        <tag>PCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6 features (3)]]></title>
    <url>%2F2018%2F01%2F30%2FECMAScript-6-3%2F</url>
    <content type="text"><![CDATA[Data-Structure Set12345var s = new Set();[2,3,5,4,5,2,2].map(x =&gt; s.add(x))for (i of s) &#123;console.log(i)&#125;// 2 3 4 5 Methods: size：Returns the number of values in the Set object. add(value)：Appends a new element with the given value to the Set object. Returns the Set object. delete(value)：Removes the element associated to the value and returns the value that has(value)：Returns a boolean asserting whether an element is present with the given value in the Set object or not. clear()：Removes all elements from the Set object. Tips: Set constructor could receive an array to eliminate duplicate. 12const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5 For set, 5 and ‘5’ are different, and objects are always different. 1234567let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 Iteration keys()：return an iterator for keys values()：return an iterator for values entries()：Returns a new Iterator object that contains an array of [value, value] for each element in the Set object, in insertion order. 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123;console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123;console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123;console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"] forEach()：Calls callbackFn once for each value present in the Set object, in insertion order.If a thisArg parameter is provided to forEach, it will be used as the this value for each callback. 12345set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + ' : ' + value))// 1 : 1// 4 : 4// 9 : 9 MapProperties/Methodssize12345const map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2 set(key, value)12345const m = new Map();m.set('edition', 6)m.set(262, 'standard')m.set(undefined, 'nah') get(key)123456const m = new Map();const hello = function() &#123;console.log('hello');&#125;;m.set(hello, 'Hello ES6!') // key is a function!m.get(hello) // Hello ES6! has(key)return a boolean shows if a key exists in the map object.12345678910const m = new Map();m.set('edition', 6);m.set(262, 'standard');m.set(undefined, 'nah');m.has('edition') // truem.has('years') // falsem.has(262) // truem.has(undefined) // true delete(key)123456const m = new Map();m.set(undefined, 'nah');m.has(undefined) // truem.delete(undefined)m.has(undefined) // false clear()clear all elements, no return value1234567let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2map.clear()map.size // 0 override:1234567const map = new Map();map.set(1, 'aaa').set(1, 'bbb');map.get(1) // "bbb" ConvertConvert Map to Array:12345const myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] Convert Array to Map:12345678new Map([[true, 7],[&#123;foo: 3&#125;, ['abc']]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; ['abc']// &#125; Convert Map to Object:If keys for map are all strings, the convertion is accepted.12345678910111213function strMapToObj(strMap) &#123;let obj = Object.create(null);for (let [k,v] of strMap) &#123;obj[k] = v;&#125;return obj;&#125;const myMap = new Map().set('yes', true).set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; Convert Object to Map:12345678910function objToStrMap(obj) &#123;let strMap = new Map();for (let k of Object.keys(obj)) &#123;strMap.set(k, obj[k]);&#125;return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;"yes" =&gt; true, "no" =&gt; false&#125; Convert Map to JSON:(1) Keys are stings1234567function strMapToJson(strMap) &#123;return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;"yes":true,"no":false&#125;' (2)Keys contain non string1234567function mapToArrayJson(map) &#123;return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]' Convert JSON to Map:123456function jsonToStrMap(jsonStr) &#123;return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap('&#123;"yes": true, "no": false&#125;')// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125; Differences between Object and Map object has a prototype so there are default keys can be bypassed using map = Object.create(null) object keys are string whereas map keys can be anything map keeps track of size use maps over objects when keys are unknown until run time use objects when there is logic that operates on individual elements WeakSet iterate through providing keys only not enumerable unique object references only accept objects Differences between Set and WeakSet WeakSets are collections of object types only references to objects in the collection are held weakly 123456789var myWeakSet = new WeakSet();var foo = &#123;&#125;;var bar = &#123;&#125;;myWeakSet.add(foo);myWeakSet.has(bar); // falsemyWeakSet.has(foo); // truemyWeakSet.delete(foo);myWeakSet.add(&#123; kobe: 24 &#125;); // But because the added object has no other references, it will not be held in the set WeakMap iterate through providing keys only not enumerable unique object or function references does not accept primitive data types as keys 12345678var myWeakMap = new WeakMap();var obj1 = &#123;&#125;;var obj2 = function()&#123;&#125;;myWeakMap.set(obj1, "cat");myWeakMap.set(obj2, 24);myWeakMap.has(obj1); // truemyWeakMap.get(obj2); // 24myWeakMap.delete(obj1);]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6 features (2)]]></title>
    <url>%2F2018%2F01%2F28%2FECMAScript-6-2%2F</url>
    <content type="text"><![CDATA[FunctionDefault Parameter ValuesSimple and intuitive default values for function parameters. 1234function f (x, y = 7, z = 42) &#123;return x + y + z&#125;f(1) === 50 Rest ParameterAggregation of remaining arguments into single parameter of variadic functions. 1234function f (x, y, ...a) &#123;return (x + y) * a.length&#125;f(1, 2, "hello", true, 7) === 9 Spread OperatorSpreading of elements of an iterable collection (like an array or even a string) into both literal elements and individual function parameters. 12345678910var params = [ "hello", true, 7 ]var other = [ 1, 2, ...params ] // [ 1, 2, "hello", true, 7 ]function f (x, y, ...a) &#123;return (x + y) * a.length&#125;f(1, 2, ...params) === 9var str = "foo"var chars = [ ...str ] // [ "f", "o", "o" ] Strict modeSince ES5, strict mode could be applied within function.In ES6, if a function uses default parameter value, rest parameter or spread operator, strict mode couldn’t be used in the function. Name 12function foo() &#123;&#125;foo.name // "foo" Arrow Functions1var f = v =&gt; v; equals: 123var f = function(v) &#123;return v;&#125;; If there is no arguments or more than 1 arguments, use bracket. 123456789var f = () =&gt; 5;// equalsvar f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// equalsvar sum = function(num1, num2) &#123;return num1 + num2;&#125;; Example of arrow function combining with rest parameters: 123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] Tail CallDefinition: call one function at the last step of another function.123function f(x)&#123;return g(x);&#125; Tail Recursion A recursive function is tail recursive when recursive call is the last thing executed by the function. 123456function factorial(n, total) &#123;if (n === 1) return total;return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 The tail recursive functions considered better than non tail recursive functions as tail-recursion can be optimized by compiler. The idea used by compilers to optimize tail-recursive functions is simple, since the recursive call is the last statement, there is nothing left to do in the current function, so saving the current function’s stack frame is of no use (See this for more details). Example: (Fibonacci) Non tail recursive: 123456789function Fibonacci (n) &#123;if ( n &lt;= 1 ) &#123;return 1&#125;;return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // overflowFibonacci(500) // overflow Tail recursive: 123456789function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;if( n &lt;= 1 ) &#123;return ac2&#125;;return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6 features (1)]]></title>
    <url>%2F2018%2F01%2F28%2FECMAScript-6-1%2F</url>
    <content type="text"><![CDATA[constSupport for constants, variables which cannot be re-assigned new content. Notice: this only makes the variable itself immutable, not its assigned content (for instance, in case the content is an object, this means the object itself can still be altered). 12345678const foo = &#123;&#125;;// add an attribute to foo, successfoo.prop = 123;foo.prop // 123// assign foo to another object, errorfoo = &#123;&#125;; // TypeError: "foo" is read-only letBlock-scoped variables (and constants) without hoisting. ‘let’ only validates in scope: 123456789101112131415&#123;let a = 10;var b = 1;&#125;a // ReferenceError: a is not defined.b // 1which is useful in for loop:for (let i = 0; i &lt; 10; i++) &#123;// ...&#125;console.log(i);// ReferenceError: i is not defined Temporal dead zone (TDZ)If a variable is declared by ‘let’ in a block scope, it’s binding to the block scope and refrain from outside. 1234567891011if (true) &#123;// TDZ starttmp = 'abc'; // ReferenceErrorconsole.log(tmp); // ReferenceErrorlet tmp; // TDZ endconsole.log(tmp); // undefinedtmp = 123;console.log(tmp); // 123&#125; Repeat declaration is not allowed 1234567891011// errorfunction func() &#123;let a = 10;var a = 1;&#125;// errorfunction func() &#123;let a = 10;let a = 1;&#125; ES6 has 6 methods of variable declarationES5 has two methods of variable declaration: var, function;ES6 has 4 more methods: let, const, import, class.]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello world]]></title>
    <url>%2F2018%2F01%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello world This website is Yu Liu’s homepage, built by Hexo+Github pages. Contents are written with Markdown syntax. This website is for: 1. Share idea “Do not go gentle into that good night” 2. Code review1234567@requires_authorizationclass SomeClass:passif __name__ == '__main__':# A commentprint 'hello world' 3. Photography 4. Schedule and plan Set up TensorFlow environment Build personal website Solve algorithm problems Learn ASP.NET MVC Framework]]></content>
      <categories>
        <category>Documentation</category>
      </categories>
  </entry>
</search>
